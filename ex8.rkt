#lang racket #| â˜… CSC324 Fall 2019: Exercise 8 â˜… |#
#|
Module: ex8
Description: Exercise 8: Representing Evaluation Order
Copyright: (c) University of Toronto
               CSC324 Principles of Programming Languages, Fall 2019

Before starting, please review the exercise guidelines at
<https://www.cs.toronto.edu/~david/csc324/homework.html>.
|#
(provide single-assignment-form condensed-single-assignment-form)

;-------------------------------------------------------------------------------
; â˜… Task 1: Single assignment form â˜…
;-------------------------------------------------------------------------------
#|
(single-assignment-form expr) -> (listof datum?)
  expr: datum?
    A datum generated by the language grammar from the handout.

  Returns the *single assignment form* of the given expression.
  In Racket, this will be a list of name bindings of the form
  '((define _v0 ___)
    (define _v1 ___)
    (define _v2 ___)
    ...
    (define _vn ___))

  where _vn is bound to the value of the entire expression.

 Technical hints:
 1. If you want to use an accumulator that stores more than one type of value,
    you can either create your own struct or just use a list.
 2. You can use either `~a` or `format` to generate the identifier names as strings,
    and then `string->symbol` to convert them into symbols.
 3. A good starting point is to define a main recursive helper that takes both
    and <expr> and a list of bindings (this is the "accumulator" parameter).
|#
(define (single-assignment-form expr)
  (void))


#;(module+ test
  (require rackunit)

  (test-equal? "Numeric literal"
               (single-assignment-form 5)
               '((define _v0 5)))

  (test-equal? "Identifier"
               (single-assignment-form 'x)
               '((define _v0 x)))

  (test-equal? "First example from handout"
               (single-assignment-form '(* 2 3 x))
               '((define _v0 *)
                 (define _v1 2)
                 (define _v2 3)
                 (define _v3 x)
                 (define _v4 (_v0 _v1 _v2 _v3))))

  (test-equal? "Second example from handout"
               (single-assignment-form '(+ (* 2 3) (* 6 7)))
               '((define _v0 +)
                 (define _v1 *)
                 (define _v2 2)
                 (define _v3 3)
                 (define _v4 (_v1 _v2 _v3))
                 (define _v5 *)
                 (define _v6 6)
                 (define _v7 7)
                 (define _v8 (_v5 _v6 _v7))
                 (define _v9 (_v0 _v4 _v8)))))


;-------------------------------------------------------------------------------
; â˜… Task 2: Condensed Single Assignment Form â˜…
;-------------------------------------------------------------------------------
#|
(condensed-single-assignment-form expr) -> (listof datum?)
  expr: datum?
    A datum generated by the language grammar from the handout.

  Returns the *condensed single assignment form* of the given expression.
  *We will not test this function on an <expr> that is atomic (number/identifier).*
  You may freely choose how to handle this case, which may depend on the rest of
  your implementation.
|#
(define (condensed-single-assignment-form expr)
  (void))

#;(module+ test
  (test-equal? "First example from handout"
               (condensed-single-assignment-form '(* 2 3 x))
               '((define _v0 (* 2 3 x))))

  (test-equal? "Second example from handout"
               (condensed-single-assignment-form '(+ (* 2 3) (* 6 7)))
               '((define _v0 (* 2 3))
                 (define _v1 (* 6 7))
                 (define _v2 (+ _v0 _v1)))))