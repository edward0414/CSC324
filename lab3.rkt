#lang racket #| â˜… CSC324 Fall 2019: Lab 3 â˜… |#
#|
Module: lab3
Description: Lab 3: A Simple Interpreter
Copyright: (c) University of Toronto
               CSC324 Principles of Programming Languages, Fall 2019

Lab handout: https://www.cs.toronto.edu/~david/csc324/labs/lab3/handout.html.
|#

;-------------------------------------------------------------------------------
; â˜… Task 1: An arithmetic interpreter â˜…
;-------------------------------------------------------------------------------
#| Arithmetic Language Grammar, Version 1

<expr> = NUMBER              (* numeric literal *)
       | <expr> <op> <expr>  (* note: operators are written infix for this exercise *)
       ;

<op> = "+" | "*" ;
|#

#|
(interpret-arith expr) -> integer?
  expr: datum?
    Generated by "Arithmetic Language Grammar, Version 1".

  Returns the value of the given expression (+ and * have their usual mathematical meaning).

  Reminder: use structural pattern-matching on a list of fixed length by using the
  `list` name in the pattern. For example, the define/match clause
  [((list a b c)) b] would match (1 2 3) and evaluate to 2, while the clause
  [((list a 2 c)) c] would match '(1 2 3) but *not* '(2 3 4).

  You can also try using (? number?) as a pattern that matches any numeric value.

  See https://docs.racket-lang.org/reference/match.html for more information.
|#
(define (interpret-arith expr)
  (cond 
    [(null? expr) null]
    [(integer? expr) expr]
    [(list? expr)
     (cond
       [(equal? (second expr) '+) (+ (interpret-arith (first expr)) (interpret-arith (third expr)))]
       [else (* (interpret-arith (first expr)) (interpret-arith (third expr)))])]
    [else expr]))

(module+ test
  (require rackunit)

  (test-equal? "Numeric literal"
               (interpret-arith 3)
               3)
  (test-equal? "Simple addition"
               (interpret-arith '(4 + 5))
               9)
  (test-equal? "Simple nested binary operations"
               (interpret-arith '((1 + 3) * (6 + 10)))
               64))


;-------------------------------------------------------------------------------
; â˜… Task 2: An arithmetic interpreter with an environment â˜…
;-------------------------------------------------------------------------------
#| Arithmetic Language Grammar, Version 1

<expr> = NUMBER              (* numeric literal *)
       | <expr> <op> <expr>  (* note: operators are written infix for this exercise *)
       | IDENTIFIER          (* identifier *)
       ;

<op> = "+" | "*" ;
|#

#|
(interpret-arith-with-ids env expr) -> integer?
  env: (hash/c symbol? integer?)
    The given identifier environment (mapping identifiers to their values).
  expr: datum?
    Generated by "Arithmetic Language Grammar, Version 2".

  You may assume that all identifiers in `expr` are present in `env`.

  Hint: you should be able to start by copy-and-pasting your implementation of
  `interpret-arith` from the previous task. You'll need to distinguish numeric values
  from *symbols* that represent identifiers.

  Relevant documentation:
    https://docs.racket-lang.org/reference/hashtables.html (look up `hash-ref`)

  Note: if you want to use define/match here, you need to provide both pattern arguments.
  Since you probably won't need to destructure `env`, you can use a pattern like
  [(_ (whatever-pattern-you-want-for-expr)) ...].
|#
(define (interpret-arith-with-ids env expr)
  (cond 
    [(null? expr) null]
    [(integer? expr) expr]
    [(list? expr)
     (cond
       [(equal? (second expr) '+) (+ (interpret-arith-with-ids env (first expr)) (interpret-arith-with-ids env (third expr)))]
       [else (* (interpret-arith-with-ids env (first expr)) (interpret-arith-with-ids env (third expr)))])]
    [else (hash-ref env expr null)]))


(module+ test
  (let* ([env (hash 'a 1)])
    (test-equal? "Simple environment {a: 1}"
                 (interpret-arith-with-ids env '(a + 3))
                 4))
  (let* ([env (hash 'a 100
                    'b -3)])
    (test-equal? "Simple environment {a: 100, b: -3}"
                 (interpret-arith-with-ids env '(a * b))
                 -300)))
