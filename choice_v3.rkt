#lang racket #| â˜… Choices and backtracking, Version 3 â˜… |#
(provide DONE -< next! reset-choices! generate num-between ?- backtrack!)

#| Racket Notes

1.  In the DrRacket menu, go to Language -> Choose Language...
    Click on Show Details, and make sure "Enforce constant definitions
    is *NOT* checked.
|#
(require racket/control)

#|
A (private) global variable storing a stack of choice points (thunks).
|#
(define choices null)
(define (set-choices! val) (set! choices val))
(define (reset-choices!) (set-choices! null))

; A constant representing the state of having "no more choices".
(define DONE 'done)

(define-syntax -<
  (syntax-rules ()
    ; Given one option, reset `choices` and return the option.
    [(-< <expr1>)
     <expr1>]

    ; If there are two or more values, return the first one and
    ; store the others in a thunk.
    [(-< <expr1> <expr2> ...)
     (shift k
       ; 1. Update `choices` to store a *thunk* that wraps the
       ;    remaining expressions. None of them are evaluated.
       (add-choice! (thunk (k (-< <expr2> ...))))

       ; 2. Evaluate and return the first expression.
       (k <expr1>))]))


#|
(next!) -> any

  Returns the next choice, or DONE if there are no more choices.
|#
(define (next!)
  (if (null? choices)
      (shift k DONE)
      (reset ((get-choice!)))))


;-------------------------------------------------------------------------------
; â˜… Stack helpers â˜…
;-------------------------------------------------------------------------------
; Wrapper functions around the push! and pop! macros.
; This is necessary for exporting purposes, as Racket doesn't allow
; mutation of module identifiers from outside of the module.
; See https://docs.racket-lang.org/guide/module-set.html.
(define (add-choice! c) (push! choices c))
(define (get-choice!) (pop! choices))

(define-syntax push!
  (syntax-rules ()
    [(push! <id> obj)
     (set! <id> (cons obj <id>))]))

(define-syntax pop!
  (syntax-rules ()
    [(pop! <id>)
     (let* ([obj (first <id>)])
       (set! <id> (rest <id>))
       obj)]))


;-------------------------------------------------------------------------------
; â˜… Turning the choices into a stream â˜…
;-------------------------------------------------------------------------------
#|
(all-choices) -> stream?

  Returns a stream containing the currently-stored choices.
|#
(define (all-choices)
  (let* ([val (reset (next!))])
    (if (equal? val DONE)
        empty-stream
        (stream-cons val (all-choices)))))

#|
(generate <expr>) -> stream?
  <expr>: an expression using the ambiguous operator -<

  Evaluates to a stream containing all choices generated by <expr>.
  Note that this is basically (all-choices), except it captures the
  original expression as well.
|#
(define-syntax generate
  (syntax-rules ()
    [(generate <expr>)
     (let* ([val (reset <expr>)])
       (if (equal? val DONE)
           empty-stream
           (stream-cons val (all-choices))))]))


;-------------------------------------------------------------------------------
; â˜… Applications â˜…
;-------------------------------------------------------------------------------
#|
(num-between start end) -> integer?
  start: integer?
  end: integer?
    Precondition: start <= end - 1.

  Returns a *choice* of an integer between start and end - 1.
|#
(define (num-between start end)
  (if (equal? start (- end 1))
      (-< start)
      (-< start (num-between (+ 1 start) end))))


;-------------------------------------------------------------------------------
; â˜… Backtracking â˜…
;-------------------------------------------------------------------------------
#|
(?- pred expr) -> any
  pred: (-> any boolean?)
  expr: any

  Returns a choice from expr that satisfies the given predicate.
|#
(define (?- pred expr)
  (if (pred expr)
      expr
      (backtrack!)))

#|
(backtrack!) -> any

  Like (next!), except it always discards its current continuation
  (next! only does this when there are no more choices).
  Useful for backtracking to escape out of nested expressions.
|#
(define (backtrack!)
  (shift k (next!)))